local M = {}

-- Configurable options
local config = {
    hidden = true,       -- Include hidden files
    follow_symlinks = false,  -- Follow symbolic links
    max_results = 100,   -- Maximum number of results to show
    border = "rounded",  -- Border style for the window
    highlight_ns = vim.api.nvim_create_namespace("XplrrHighlight"),  -- Namespace for highlights
}

-- State management
local state = {
    buf = nil,
    win = nil,
    search_term = "",
    results = {},
    selected_index = 0,  -- 0 = search input, 1+ = file selection
    cwd = vim.fn.getcwd(),
    extmark_id = nil,
    all_files = {},      -- Cache all files in the directory
    original_win = nil,  -- Original window before opening finder
}

-- Utility functions
local function is_windows()
    return package.config:sub(1,1) == "\\"
end

-- Convert path to use ~ for home directory
local function shorten_path(path)
    local home = vim.env.HOME or vim.env.USERPROFILE
    if home then
        home = home:gsub("\\", "/")
        local normalized_path = path:gsub("\\", "/")
        if normalized_path:sub(1, #home) == home then
            return "~" .. normalized_path:sub(#home + 1)
        end
    end
    return path
end

local function is_valid_buf(buf)
    return buf and vim.api.nvim_buf_is_valid(buf)
end

local function scan_directory(dir)
    local files = {}
    local cmd = is_windows() and
        "dir \""..dir.."\" /b /s /a-d" or
        "find \""..dir.."\" -type f" .. (config.hidden and "" or " -not -path \"*/.*\"")

    local handle = io.popen(cmd)
    if handle then
        for file in handle:lines() do
            -- Normalize path separators
            file = file:gsub("\\", "/")
            -- Make relative to cwd
            local cwd_normalized = state.cwd:gsub("\\", "/")
            if cwd_normalized:sub(-1) ~= "/" then
                cwd_normalized = cwd_normalized .. "/"
            end

            -- Extract relative path
            local rel_path = file
            if file:sub(1, #cwd_normalized) == cwd_normalized then
                rel_path = file:sub(#cwd_normalized + 1)
            end

            table.insert(files, rel_path)
        end
        handle:close()
    end
    return files
end

local function fuzzy_match(term, str)
    if #term == 0 then return true end
    term = term:lower()
    str = str:lower()

    local j = 1  -- position in str
    for i = 1, #term do
        local c = term:sub(i, i)
        -- Find the character in the remaining part of the string
        local found = false
        while j <= #str do
            if str:sub(j, j) == c then
                found = true
                j = j + 1
                break
            end
            j = j + 1
        end
        if not found then return false end
    end
    return true
end

local function update_results()
    if #state.search_term == 0 then
        -- Show all files when search is empty
        state.results = {}
        for i = 1, math.min(#state.all_files, config.max_results) do
            table.insert(state.results, state.all_files[i])
        end
    else
        -- Filter files based on search term
        state.results = {}
        for _, file in ipairs(state.all_files) do
            if fuzzy_match(state.search_term, file) then
                table.insert(state.results, file)
                if #state.results >= config.max_results then
                    break
                end
            end
        end
    end

    -- Adjust selection index
    if #state.results > 0 then
        if state.selected_index == 0 then
            -- Keep selection in search input
        elseif state.selected_index > #state.results then
            state.selected_index = #state.results
        end
    else
        state.selected_index = 0
    end
end

local function open_file(filepath)
    local full_path = state.cwd.."/"..filepath
    full_path = full_path:gsub("/+", "/") -- Normalize path

    -- Switch to original window and open file there
    if state.original_win and vim.api.nvim_win_is_valid(state.original_win) then
        vim.api.nvim_set_current_win(state.original_win)

        -- Use :edit command to properly handle buffer loading
        vim.cmd("edit " .. vim.fn.fnameescape(full_path))
        return true
    else
        -- Fallback to current window
        vim.cmd("edit " .. vim.fn.fnameescape(full_path))
        return true
    end
end

local function update_display()
    if not is_valid_buf(state.buf) then return end

    -- Use shortened path for display
    local display_cwd = shorten_path(state.cwd)
    local display_lines = {"XPLRR: "..display_cwd, "> "..state.search_term}

    -- Add search input and results
    for i, result in ipairs(state.results) do
        local prefix = (state.selected_index == i) and "âž¤ " or "  "
        table.insert(display_lines, prefix..result)
    end

    vim.api.nvim_buf_set_lines(state.buf, 0, -1, false, display_lines)

    -- Clear previous highlight
    if state.extmark_id then
        vim.api.nvim_buf_del_extmark(state.buf, config.highlight_ns, state.extmark_id)
        state.extmark_id = nil
    end

    -- Add highlight for selected item (if in file selection)
    if state.selected_index > 0 then
        state.extmark_id = vim.api.nvim_buf_set_extmark(
            state.buf,
            config.highlight_ns,
            state.selected_index + 1,  -- line (0-based: header + search + selected)
            0,                        -- column
            {
                hl_group = "Visual",
                end_line = state.selected_index + 1,
                end_col = 0,
                hl_eol = true,
                priority = 50,
            }
        )
    end
end

local function close_window()
    -- Clear highlight when closing
    if state.extmark_id and is_valid_buf(state.buf) then
        vim.api.nvim_buf_del_extmark(state.buf, config.highlight_ns, state.extmark_id)
    end

    if state.win and vim.api.nvim_win_is_valid(state.win) then
        vim.api.nvim_win_close(state.win, true)
    end
    state.buf = nil
    state.win = nil
    state.extmark_id = nil
end

local function create_window()
    if state.win and vim.api.nvim_win_is_valid(state.win) then
        return
    end

    -- Remember original window
    state.original_win = vim.api.nvim_get_current_win()

    -- Create buffer
    state.buf = vim.api.nvim_create_buf(false, true)
    if not is_valid_buf(state.buf) then
        vim.notify("Failed to create XPLRR buffer", vim.log.levels.ERROR)
        return
    end

    -- Scan all files in directory
    state.all_files = scan_directory(state.cwd)
    state.search_term = ""
    state.selected_index = 0
    update_results()

    -- Window dimensions
    local width = math.floor(vim.o.columns * 0.8)
    local height = math.floor(vim.o.lines * 0.6)

    -- Window options
    local win_opts = {
        relative = "editor",
        width = width,
        height = height,
        col = (vim.o.columns - width) / 2,
        row = (vim.o.lines - height) / 2,
        style = "minimal",
        border = config.border,
        title = "XPLRR",
        title_pos = "center",
    }

    -- Create window
    state.win = vim.api.nvim_open_win(state.buf, true, win_opts)
    if not state.win or not vim.api.nvim_win_is_valid(state.win) then
        vim.notify("Failed to create XPLRR window", vim.log.levels.ERROR)
        return
    end

    -- Set buffer options
    vim.bo[state.buf].filetype = "xplrr"
    vim.bo[state.buf].buftype = "nofile"
    vim.bo[state.buf].bufhidden = "wipe"
    vim.bo[state.buf].swapfile = false
    vim.bo[state.buf].omnifunc = "v:lua.vim.lsp.omnifunc"  -- prevent E764

    -- Navigation functions
    local function move_up()
        if state.selected_index == 0 then
            -- Already at top, do nothing
        elseif state.selected_index == 1 then
            -- Move from first file to search input
            state.selected_index = 0
            update_display()
            vim.api.nvim_win_set_cursor(state.win, {2, #state.search_term + 2})
            vim.api.nvim_command("startinsert")
        else
            -- Move up in file list
            state.selected_index = state.selected_index - 1
            update_display()
            vim.api.nvim_win_set_cursor(state.win, {state.selected_index + 2, 0})
        end
    end

    local function move_down()
        if state.selected_index == 0 then
            -- Move from search input to first file
            if #state.results > 0 then
                state.selected_index = 1
                update_display()
                vim.api.nvim_win_set_cursor(state.win, {3, 0})
            end
        elseif state.selected_index < #state.results then
            -- Move down in file list
            state.selected_index = state.selected_index + 1
            update_display()
            vim.api.nvim_win_set_cursor(state.win, {state.selected_index + 2, 0})
        end
    end

    -- Key mappings
    local mappings = {
        {"n", "<CR>", function()
            if state.selected_index == 0 and #state.results > 0 then
                -- Open first result when pressing Enter in search input
                if open_file(state.results[1]) then
                    close_window()
                end
            elseif state.selected_index > 0 then
                if open_file(state.results[state.selected_index]) then
                    close_window()
                end
            end
        end, {buffer = state.buf}},

        {"i", "<CR>", function()
            if state.selected_index == 0 and #state.results > 0 then
                -- Open first result when pressing Enter in search input
                if open_file(state.results[1]) then
                    close_window()
                end
            elseif state.selected_index > 0 then
                if open_file(state.results[state.selected_index]) then
                    close_window()
                end
            end
        end, {buffer = state.buf}},

        {"n", "<Esc>", close_window, {buffer = state.buf}},
        {"i", "<Esc>", close_window, {buffer = state.buf}},
        {"n", "q", close_window, {buffer = state.buf}},

        {"n", "<Up>", move_up, {buffer = state.buf}},
        {"i", "<Up>", function()
            vim.api.nvim_command("stopinsert")
            move_up()
        end, {buffer = state.buf}},

        {"n", "<Down>", move_down, {buffer = state.buf}},
        {"i", "<Down>", function()
            vim.api.nvim_command("stopinsert")
            move_down()
        end, {buffer = state.buf}},

        {"n", "<C-n>", move_down, {buffer = state.buf}},
        {"i", "<C-n>", function()
            vim.api.nvim_command("stopinsert")
            move_down()
        end, {buffer = state.buf}},

        {"n", "<C-p>", move_up, {buffer = state.buf}},
        {"i", "<C-p>", function()
            vim.api.nvim_command("stopinsert")
            move_up()
        end, {buffer = state.buf}},

        -- Disable left/right navigation in file list
        {"n", "<Left>", "<Nop>", {buffer = state.buf}},
        {"n", "<Right>", "<Nop>", {buffer = state.buf}},
        {"i", "<Left>", "<Nop>", {buffer = state.buf}},
        {"i", "<Right>", "<Nop>", {buffer = state.buf}},
    }

    for _, map in ipairs(mappings) do
        vim.keymap.set(map[1], map[2], map[3], map[4])
    end

    -- Cursor movement restriction for search line
    local function restrict_cursor()
        local cursor = vim.api.nvim_win_get_cursor(state.win)
        local line, col = cursor[1], cursor[2]

        -- Second line is index 1 (0-indexed)
        if line == 1 and col < 2 then
            vim.api.nvim_win_set_cursor(state.win, {2, 2})
        end

        -- Disable cursor movement in file list
        if line > 1 and state.selected_index == 0 then
            vim.api.nvim_win_set_cursor(state.win, {2, #state.search_term + 2})
        end
    end

    -- Autocommand for input handling
    vim.api.nvim_create_autocmd({"TextChanged", "TextChangedI"}, {
        buffer = state.buf,
        callback = function()
            local lines = vim.api.nvim_buf_get_lines(state.buf, 0, 2, false)
            if #lines >= 2 then
                local input = lines[2]:sub(3) -- Remove the "> " prefix
                if input ~= state.search_term then
                    state.search_term = input
                    update_results()
                    update_display()

                    -- Keep cursor in search input
                    if state.selected_index == 0 then
                        vim.api.nvim_win_set_cursor(state.win, {2, #state.search_term + 2})
                    end
                end
            end
        end
    })

    -- Autocommand to restrict cursor in search line
    vim.api.nvim_create_autocmd({"CursorMoved", "CursorMovedI"}, {
        buffer = state.buf,
        callback = restrict_cursor
    })

    -- Prevent modification of prefix in search line
    vim.api.nvim_create_autocmd("TextChangedI", {
        buffer = state.buf,
        callback = function()
            local line = vim.api.nvim_get_current_line()
            if #line < 2 or line:sub(1,2) ~= "> " then
                -- Restore prefix if modified
                vim.api.nvim_set_current_line("> " .. state.search_term)
                vim.api.nvim_win_set_cursor(state.win, {2, #state.search_term + 2})
            end
        end
    })

    -- Initial display
    update_display()
    vim.api.nvim_command("startinsert")
    vim.api.nvim_win_set_cursor(state.win, {2, #state.search_term + 2})
end

function M.toggle()
    if state.win and vim.api.nvim_win_is_valid(state.win) then
        close_window()
    else
        state.cwd = vim.fn.getcwd()
        create_window()
    end
end

-- Create user command
vim.api.nvim_create_user_command("Xplrr", M.toggle, {})

return M
